# Шпаргалка по 12 вопросу ООП

## Содержание
1. [Основные правила](#основные-правила)
2. [Синтаксис перегрузки](#синтаксис-перегрузки)
3. [Перегружаемые операторы](#перегружаемые-операторы)
4. [Неперегружаемые операторы](#неперегружаемые-операторы)
5. [Перегрузка во внешних функциях](#перегрузка-во-внешних-функциях)

---

## Основные правила

Перегрузка операторов позволяет определить собственное поведение операторов для пользовательских типов данных (классов и структур). Это мощный механизм, который делает код более интуитивным и удобочитаемым.

**Основные принципы перегрузки операторов**
1. Перегружать можно только существующие операторы (нельзя создавать новые)
2. Нельзя изменять приоритет операторов
3. Нельзя изменять арность оператора (количество операндов)
4. Некоторые операторы нельзя перегружать (например, `::`, `.*`, `?:`, `.`)

**Особенности перегрузки операторов**
1. Операторы как члены класса: имеют доступ к приватным членам, первый операнд - это `*this`
2. Операторы как свободные функции: часто объявляются как `friend` для доступа к приватным членам

---

## Синтаксис перегрузки

```cpp
ReturnType operator Оператор(Операнды) {
    // реализация
}
```

### Как метод класса:
```cpp
class Vector {
public:
    double x, y;
    
    Vector operator-() const {
        return Vector{-x, -y};
    }
};
// Использование
Vector v{1, 2};
Vector negV = -v;  // {-1, -2}
```

### Как внешняя функция:
```cpp
class Vector {
    double x, y;
public:
    double getX() const { return x; };
    double getY() const { return y; };
};

bool operator ==(const Vector& a, const Vector& b) const {
    return (a.getX() == b.getX() && a.getY() == b.getY());
}
```

### Friend-функции для доступа к private:
```cpp
class Vector {
    double x, y;
public:    
    friend std::ostream& operator<<(std::ostream& os, const Vector& v);
    friend std::istream& operator>>(std::istream& is, Vector& v);
};
```

---

## Перегружаемые операторы

### Арифметические:
| Операторы | Пример использования |
|-----------|----------------------|
| `+ - * / %` | `v1 + v2` |
| `+= -= *= /= %=` | `v1 += v2` |

### Битовые:    
| Операторы | Пример |
|-----------|--------|
| `& | ^ ~` | `a & b` |
| `<< >>` | `a << 3` |
| `&=, |=, ^=, <<= >>=` | `a &= 2` |

### Логические и сравнения:
| Операторы | Пример |
|-----------|--------|
| `== != < > <= >=` | `if (v1 == v2)` |
| `&& || !` | `if (!obj)` |

### Специальные:
| Операторы | Название |
|-----------|----------|
| `++a` | Префиксный инкремент |
| `a++` | Постфиксный инкремент |
| `--a` | Префиксный декремент |
| `a--` | Постфиксный декремент |
| `++a` | Префиксный инкремент |
| `a[]` | Индексация |
| `a()` | Функциональный вызов |
| `,` | Запятая |
| `(int)x` | Явное (и не явное) приведение типов |

---

## Неперегружаемые операторы

| Оператор | Пример | Название |
|----------|--------|----------|
| `::` | `std::cout` | Оператор разрешения области видимости |
| `.*` | `ptr->*data` | Оператор доступа к члену  |
| `.` | `obj.member` | Доступ к члену |
| `?:` | `a > b ? a : b` | Тернарный условный оператор |
| `sizeof` | `sizeof(obj)` | Размер объекта |
| `typeid` | `typeid(obj)` | Информация о типе |

---

## Перегрузка во внешних функциях

### Операторы, требующие методов класса:
* `=` (присваивание)
* `[]` (индексация)
* `()`  (вызов функции)
* `->` (доступ к члену через указатель)
* явное/неявное преобразование к типу

### Операторы рекомендуемые как методы классов:
* все унарные операторы
* `+= -= /= *= ^= &= |= %= >>= <<=`

### Операторы для внешних функций:

**Бинарные операторы: **
* Арифметические: `+`, `-`, `*`, `/`
* Сравнения: `==`, `!=`, `<`, `>`
* Битовые: `&`, `|`, `^`
* Потоки: `<<`, `>>`

---
